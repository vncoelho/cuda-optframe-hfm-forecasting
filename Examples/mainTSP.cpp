// OptFrame - Optimization Framework

// Copyright (C) 2009-2015
// http://optframe.sourceforge.net/
//
// This file is part of the OptFrame optimization framework. This framework
// is free software; you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License v3 as published by the
// Free Software Foundation.

// This framework is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License v3 for more details.

// You should have received a copy of the GNU Lesser General Public License v3
// along with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.

// ===================================
// Main.cpp file generated by OptFrame
// Project Traveling Salesman Problem
// ===================================

#include <stdlib.h>
#include <math.h>

#include <iostream>

using namespace std;

#include <set>

#include "../OptFrame/Loader.hpp"
#include "../OptFrame/Util/CheckCommand.hpp"
#include "../OptFrame/Util/BuildCommand.hpp"
#include "TSP.h"

using namespace TSP;
using namespace scannerpp;

int main(int argc, char **argv)
{
    Loader<RepTSP> optframe;
    TSPProblemCommand tsp;
    tsp.load("./TSP/tsplib/berlin52.txt", optframe.factory, optframe.dictionary, optframe.ldictionary);

    CheckCommand<RepTSP> check(false);

    RandGen rg;
    RandomInitialSolutionTSP random(tsp.p, rg);
    NearestNeighborConstructive cnn(tsp.p, rg);
    ConstructiveBestInsertion cbi(tsp.p, rg);
    TSPEvaluator eval(tsp.p);
    NSEnumSwap enumswap(tsp.p, rg);

    NSSeqTSP2Opt<int, OPTFRAME_DEFAULT_ADS, DeltaMoveTSP2Opt, ProblemInstance> nsseq_delta_2opt(tsp.p);
    NSSeqTSP2Opt<int> tsp2opt;
    NSSeqTSPOrOptk<int, OPTFRAME_DEFAULT_ADS, DeltaMoveTSPOrOptk, ProblemInstance> nsseq_delta_or1(1, tsp.p);
    NSSeqTSPOrOptk<int> tspor1(1);
    NSSeqTSPOrOptk<int> tspor2(2);
    NSSeqTSPOrOptk<int> tspor3(3);
    NSSeqTSPSwap<int> tspswap;

    check.add(random);
    check.add(cnn);
    check.add(cbi);
    check.add(eval);
    check.add(enumswap);
    check.add(nsseq_delta_2opt);
    check.add(tsp2opt);
    check.add(nsseq_delta_or1);
    check.add(tspor1);
    check.add(tspor2);
    check.add(tspor3);
    check.add(tspswap);

    //check.run(100, 10);

    BuildCommand<RepTSP> build;
    for (unsigned i = 0; i <= 7; i++)
    {
        stringstream ss;
        ss << "OptFrame:ComponentBuilder:LocalSearch:BI  OptFrame:Evaluator 0  OptFrame:NS:NSSeq " << i;
        string name = build.run(optframe.factory, optframe.dictionary, optframe.ldictionary, ss.str());
        cout << "BUILT: '" << name << "'" << endl;
    }

    vector<LocalSearch<RepTSP>*> ns_list;
    ns_list.push_back(new BestImprovement<RepTSP>(eval, tsp2opt));
    ns_list.push_back(new BestImprovement<RepTSP>(eval, tspor1));
    ns_list.push_back(new BestImprovement<RepTSP>(eval, tspor2));
    ns_list.push_back(new BestImprovement<RepTSP>(eval, tspor3));
    ns_list.push_back(new BestImprovement<RepTSP>(eval, tspswap));

    VariableNeighborhoodDescent<RepTSP> VND(eval, ns_list);

    ILSLPerturbationLPlus2<RepTSP> pert(eval, 10, tsp2opt, rg);
    pert.add_ns(tspor1);
    pert.add_ns(tspor2);
    pert.add_ns(tspor3);
    pert.add_ns(tspswap);

    IteratedLocalSearchLevels<RepTSP> ils(eval, random, VND, pert, 3, 2);
    ils.setMessageLevel(4);

    cout << "will run ils" << endl;
    pair<Solution<RepTSP>&, Evaluation&>& psol = *ils.search(1000, 0, NULL, NULL);
    eval.Minimizing = false;
    pair<Solution<RepTSP>&, Evaluation&>& psol2 = *ils.search(1000, 99999999, NULL, NULL);

    psol.first.print();
    psol.second.print();

    cout << "solMin=" << eval.solMin << endl;
    cout << "solMax=" << eval.solMax << endl;

    int count = 0;
    for (int i = eval.solMin; i <= eval.solMax; i++)
        if (eval.solutions[i] > 0)
            count += eval.solutions[i];
    cout << "COUNT=" << count << endl;

    cout << "count min = " << eval.solutions[eval.solMin] << endl;
    cout << "count max = " << eval.solutions[eval.solMax] << endl;

    int countun = 0;
    for (int i = eval.solMin; i <= eval.solMax; i++)
        if (eval.solutions[i] > 0)
            countun++;
    cout << "COUNT_UNIQUE=" << countun << endl;

    FILE* fstat = fopen("stat.txt", "w");
    fprintf(fstat, "x=c(");
    for (int i = eval.solMin; i <= eval.solMax; i++)
        if (eval.solutions[i] > 0)
            fprintf(fstat, "%d,", i);
    fclose(fstat);

    FILE* fstatti = fopen("stat_total_imp.txt", "w");
    fprintf(fstatti, "x=c(");
    for (int i = eval.solMin; i <= eval.solMax; i++)
        if (eval.solutions[i] > 0)
            fprintf(fstat, "%d\t%lld\t%lld\t%.5f\n,", i, eval.solNSTotal[i], eval.solNSImp[i], 100 * float(eval.solNSImp[i]) / float(eval.solNSTotal[i]));
    fclose(fstatti);

    /*
     echo building VND
     define vnd_list [ OptFrame:LocalSearch: 0 ,  OptFrame:LocalSearch: 1, OptFrame:LocalSearch: 2, OptFrame:LocalSearch: 3 ]
     component.create_list $vnd_list OptFrame:LocalSearch: comp_vnd_list
     build OptFrame:LocalSearch:VND   $Evaluator 0   $comp_vnd_list   vnd

     %component.list

     echo building ILS
     build OptFrame:ComponentBuilder:SingleObjSearch:ILS:ILSLevels   $Evaluator 0    $Constructive 0    $vnd   OptFrame:ILS:LevelPert:LPlus2 0    100    8  meu_ils

     test 2 3 7000 7000   $Evaluator 0   $meu_ils   output.txt   solucao_saida

     evaluate $Evaluator 0 $solucao_saida
     */

    cout << "Program ended successfully" << endl;

    return 0;
}
